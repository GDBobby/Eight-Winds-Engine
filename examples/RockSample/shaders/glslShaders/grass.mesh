#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : enable

#include "SimplexNoise.glsl"
//#extension GL_EXT_debug_printf : enable

#define PI 3.1415926535897932384626433832795

#define TWO_PI 6.283185307179586476925286766559

//https://www.geeks3d.com/20200519/introduction-to-mesh-shaders-opengl-and-vulkan/
//https://gpuopen.com/learn/mesh_shaders/mesh_shaders-procedural_grass_rendering/

const int GROUP_SIZE       = 128;
const uint GRASS_VERT_COUNT = 256;
const uint GRASS_PRIM_COUNT = 192;
const uint verticesPerBladeEdge = 4;
const uint verticesPerBlade =  8;//2 * verticesPerBladeEdge;
const uint trianglesPerBlade = 6;//verticesPerBlade - 2
const uint maxBladeCount = 32;


layout(set = 0, binding = 0) uniform GlobalUbo{
	mat4 projView;
	vec4 cameraPos;
} ubo;

layout(set = 0, binding = 2) uniform GrassBufferObject{
    float spacing;
    float height;
    float time;
    float windDir;
    float endDistance;
    float windStrength;
} gbo;

struct VertexOutput{
    vec3 worldPos;
    vec3 worldNormal;
    float rootHeight;
    float height;
};
//void PrintVertex(VertexOutput v, uint vertId){
    //debugPrintfEXT("vert[%d] - height %f root_height %f worldPos %f %f %f normal %f %f %f\n", vertId, v.height, v.rootHeight, v.worldPos.x, v.worldPos.y, v.worldPos.z, v.worldNormal.x, v.worldNormal.y, v.worldNormal.z);
//}


layout(location = 0) out VertexOutput v_out[];  // [max_vertices]

uint combineSeed(const float x, const float y) {
    return (floatBitsToUint(x) ^ (floatBitsToUint(y) * 0x6C078965u)) * 0x9E3779B9u;
}

int tsign(in uint gtid, in int id) {
    return ((gtid & (1u << id)) != 0) ? 1 : -1;
}

#define saturate(value) clamp(value, 0.0, 1.0)

uvec4 pcg4d(uvec4 v) {
    v = v * 1664525u + 1013904223u;
    v.x += v.y * v.w;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    v.w += v.y * v.z;
    v = v ^ (v >> 16u);
    v.x += v.y * v.w;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    v.w += v.y * v.z;
    return v;
}
float rand1(inout uvec4 rng_state) {
    rng_state.w++;
    return uintBitsToFloat(pcg4d(rng_state).x);
}
vec3 GetWindOffset(vec2 pos, float time){    
    const float posOnSineWave = cos(gbo.windDir) * pos.x - sin(gbo.windDir) * pos.y;
    
    const float t     = time + posOnSineWave + 4.0 * SimplexNoise(0.1 * pos);
    const float windx = 2.0 * sin(.5 * t);
    const float windy = sin(1. * t);
    
    return gbo.windStrength * vec3(windx, windy, 0);
}

void MakePersistentLength(in vec3 groundPos, inout vec3 v1, inout vec3 v2, in float height) {
    //Persistent length
    vec3 v01 = v1 - groundPos;
    vec3 v12 = v2 - v1;
    const float lv01 = length(v01);
    const float lv12 = length(v12);

    const float L1 = lv01 + lv12;
    const float L0 = length(v2 - groundPos); //https://github.com/klejah/ResponsiveGrassDemo/blob/6ce514717467acc80fd965a6f7695d5151ba8c03/ResponsiveGrassDemo/shader/Grass/GrassUpdateForcesShader.cs#L76
    const float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    const float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 = groundPos + v01;
    v2 = v1 + v12;
}

vec3 bezier(vec3 p0, vec3 p1, vec3 p2, float t) {
    const vec3 a = mix(p0, p1, t);
    const vec3 b = mix(p1, p2, t);
    return mix(a, b, t);
}
vec3 bezierDerivative(vec3 p0, vec3 p1, vec3 p2, float t) {
    return 2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1);
}


layout(triangles) out;
layout(max_vertices = GRASS_VERT_COUNT, max_primitives = GRASS_PRIM_COUNT) out;
layout(local_size_x = GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main(){

    //SetMeshOutputsNV(GRASS_VERT_COUNT, GRASS_PRIM_COUNT);
    SetMeshOutputsEXT(GRASS_VERT_COUNT, GRASS_PRIM_COUNT);

    /*
	gl_MeshVerticesEXT[0].gl_Position = ubo.projView * vec4( 0.0, -1.0, gl_GlobalInvocationID.x, 1.0);
	gl_MeshVerticesEXT[1].gl_Position = ubo.projView * vec4(-1.0,  1.0, gl_GlobalInvocationID.x, 1.0);
	gl_MeshVerticesEXT[2].gl_Position = ubo.projView * vec4( 1.0,  1.0, gl_GlobalInvocationID.x, 1.0);
	
	gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] =  uvec3(0, 1, 2);
    */

    const float  spacing     = gbo.spacing;
    //const vec3 patchCenter = arguments.position;
    const vec3 patchNormal = vec3(0.0, -1.0, 0.0);

    const vec2 horiPos = vec2(spacing * gl_LocalInvocationID.x, spacing * gl_WorkGroupID.y);
    const float simpNoise = NoiseWithOctaves(horiPos / 1000.0, 8) * 32.0;
    const vec3 patchCenter = vec3(horiPos.x, simpNoise, horiPos.y);
    //debugPrintfEXT("patchcenter - %f:%f:%f", patchCenter.x, patchCenter.y, patchCenter.z);
    
    //const uint seed           = combineSeed(patchCenter.x / spacing, patchCenter.y / spacing);
    uvec4 seed = uvec4(gl_WorkGroupID.x, 0, 0, 0);
	
    const float distanceToCamera = distance(patchCenter, ubo.cameraPos.xyz);
    float bladeCountF      = mix(float(maxBladeCount), 2.0, pow(saturate(distanceToCamera / (gbo.endDistance * 1.05)), 0.75));
    //debugPrintfEXT("camera, blade count - %f:%f", distanceToCamera, bladeCountF);
    
    const uint bladeCount = uint(ceil(bladeCountF));
    
    const uint vertexCount   = bladeCount * verticesPerBlade;
    const uint triangleCount = bladeCount * trianglesPerBlade;
        
    for (uint i = 0; i < 2; i++){
        uint vertId = gl_LocalInvocationID.x + GROUP_SIZE * i;

        if (vertId >= vertexCount){
            //debugPrintfEXT("break cause vertId >= vertexCount");
            break;
        }

        
        uint bladeId     = vertId / verticesPerBlade;        
        uint vertIdLocal = vertId % verticesPerBlade;
        
        seed.y = bladeId;
        const float height = gbo.height + (fract(rand1(seed)) - 0.5) * 0.5;
        
        //position the grass in a circle around the patchPosition and angled using the patchNormal
        vec3 tangent   = normalize(cross(vec3(0.0, 0.0, 1.0), patchNormal));
        vec3 bitangent = normalize(cross(patchNormal, tangent));
        //debugPrintfEXT("tangent, bitangent - (%f):(%f):(%f) - (%f):(%f):(%f)", tangent.x, tangent.y, tangent.z, bitangent.x, bitangent.y, bitangent.z);
        if(isnan(tangent.x) || isnan(tangent.y) || isnan(tangent.z)){
            tangent.x = 1.0;
            tangent.y = 0.0;
            tangent.z = 0.0;
        }        
        if(isnan(bitangent.x) || isnan(bitangent.y) || isnan(bitangent.z)){
            bitangent.x = 1.0;
            bitangent.y = 0.0;
            bitangent.z = 0.0;
        }

             
        const float bladeDirectionAngle = TWO_PI * fract(rand1(seed));
        const vec2 bladeDirection      = vec2(cos(bladeDirectionAngle), sin(bladeDirectionAngle));
       
        const float offsetAngle  = TWO_PI * fract(rand1(seed));
        const float offsetRadius = spacing * fract(rand1(seed));
        const vec3 bladeOffset  = offsetRadius * (cos(offsetAngle) * tangent + sin(offsetAngle) * bitangent);
        //debugPrintfEXT("offsetAngle - offsetRadius - bladeOffset : (%f) - (%f) - (%f):(%f):(%f)", offsetAngle, offsetRadius, bladeOffset.x, bladeOffset.y, bladeOffset.z);
        
        vec3 p0 = patchCenter + bladeOffset;
       // debugPrintfEXT("initial p0 - (%f):(%f):(%f)", p0.x, p0.y, p0.z);

        vec3 p1 = p0 + vec3(0.0, -height, 0.0);
        vec3 p2 = p1 + vec3(bladeDirection.x * height * 0.3, 0.0, bladeDirection.y * height * 0.3);
     
        p2 += GetWindOffset(p0.xy, gbo.time);

        seed.z = 0;
        
        MakePersistentLength(p0, p1, p2, height);
        
        float width = 0.03;
        
        width *= maxBladeCount / bladeCountF;
        
        if (bladeId == (bladeCount - 1)) {
            width *= fract(bladeCountF);
        }
        
        vec3 sideVec = normalize(vec3(bladeDirection.y, 0.0, -bladeDirection.x));
        vec3 offset  = tsign(vertIdLocal, 0) * width * sideVec;
        
        VertexOutput vertex;
        vertex.height = height;
        vertex.rootHeight = p0.z;

        p0 += offset * 1.0;
        p1 += offset * 0.7;
        p2 += offset * 0.3;
          
        float t = (vertIdLocal/2) / float(verticesPerBladeEdge - 1);
        const vec3 worldPos = bezier(p0, p1, p2, t);
        vertex.worldPos = worldPos;
        //v_out[vertId].worldSpacePosition = worldPos;
        //v_out[vertId].worldSpaceNormal = cross(sideVec, normalize(bezierDerivative(p0, p1, p2, t)));
        vertex.worldNormal = cross(sideVec, normalize(bezierDerivative(p0, p1, p2, t)));
        gl_MeshVerticesEXT[vertId].gl_Position = ubo.projView * vec4(worldPos, 1);
        //PrintVertex(vertex, vertId);
        v_out[vertId] = vertex;
    }

    for (uint i = 0; i < 2; i++){
        uint triId = gl_LocalInvocationID.x + GROUP_SIZE * i;

        if (triId >= triangleCount) {
           // debugPrintfEXT("triID greater thjan triangleCount");
            break;
        }

        uint bladeId    = triId / trianglesPerBlade;
        uint triIdLocal = triId % trianglesPerBlade;

        uint offset = bladeId * verticesPerBlade + 2 * (triIdLocal / 2);

        uvec3 triangleIndices = (triIdLocal % 2 == 0) ? uvec3(0, 1, 2) : uvec3(3, 2, 1);

        uvec3 tri = offset + triangleIndices;

        gl_PrimitiveTriangleIndicesEXT[triId] = tri;
    }   
}
